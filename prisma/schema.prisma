generator client {
  provider = "prisma-client-js"
  output   = "./node_modules/@prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(uuid())
  username       String
  hashedPassword Bytes
  salt           Bytes
  email          String   @unique
  role           UserRole
  profilePicture Json?
  userDetails    Json?
  loyaltyStatus  Loyalty? @default(Not_Eligible)
  orderPoint     Float?   @default(0.00)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  updatedById  String? // Foreign key reference to another User
  updatedBy    User?   @relation("UserUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
  updatedUsers User[]  @relation("UserUpdatedBy") // Inverse relation: Tracks users this user has updated
  orders       Order[] @relation("UserOrders") // Unique relation name for the relation with orders

  @@index([email]) // Index on email for faster queries
}

model Size {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name]) // Index on size name for better query performance
}

model Category {
  id        String   @id @default(uuid())
  name      String // No @unique here
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parentCategoryId String?
  parentCategory   Category?  @relation("CategoryHierarchy", fields: [parentCategoryId], references: [id], onDelete: SetNull)
  subcategories    Category[] @relation("CategoryHierarchy")

  products            Product[] @relation("ProductCategoryRelation")
  parentProducts      Product[] @relation("ProductParentCategoryRelation")
  subcategoryProducts Product[] @relation("ProductSubCategoryRelation")

  // This ensures 'name' is unique only within its parent category
  @@unique([name, parentCategoryId])
  @@index([name]) // Still keep an index on name for general queries
}

model Product {
  id           String    @id @default(uuid())
  title        String
  brandName    String?
  color        String?
  sku          String    @unique
  images       Json[] // Assuming images are stored as URLs
  itemLocation String? // Warehouse/store location
  notes        String?
  sizeId       String?
  sizeType     String?
  sizes        String?
  postName     String?
  categoryId   String? // Child category ID
  category     Category? @relation(fields: [categoryId], references: [id], name: "ProductCategoryRelation")

  subCategoryId String? // Subcategory ID
  subCategory   Category? @relation(fields: [subCategoryId], references: [id], name: "ProductSubCategoryRelation")

  parentCategoryId String? // Parent category ID
  parentCategory   Category? @relation(fields: [parentCategoryId], references: [id], name: "ProductParentCategoryRelation")
  ebayId           String?
  wallmartId       String?
  sheinId          String?
  woocommerceId    String?

  regularPrice    Float?
  salePrice       Float?
  platFormPrice   Float?
  toggleFirstDeal Boolean? @default(true) // toggle 10% discount for first deal
  discountPercent Float?
  stockQuantity   Int?
  condition       String? // New, Used, Refurbished, etc.
  description     String?
  status          String?
  isPublished     Boolean? @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  updatedById     String? // Foreign key reference to another User
  ebayOne         Boolean  @default(false)
  ebayTwo         Boolean  @default(false)
  ebayThree       Boolean  @default(false)

  search_vector Unsupported("tsvector")?
  variants      ProductVariant[]
  orderDetails  OrderDetail[]            @relation("ProductOrderDetails")
  changeHistory ProductChangeHistory[]

  @@index([sku])
  @@index([brandName])
  @@index([title])
  @@index([categoryId])
  @@index([subCategoryId])
  @@index([parentCategoryId]) // Index for fast lookup by parent category
}

model ProductChangeHistory {
  id              String   @id @default(uuid())
  productId       String
  oldItemLocation String?
  newItemLocation String?
  oldNotes        String?
  newNotes        String?
  changedAt       DateTime @default(now())

  product Product @relation(fields: [productId], references: [id])
}

model ProductVariant {
  id            String    @id @default(uuid())
  productId     String
  product       Product   @relation(fields: [productId], references: [id])
  color         String // Color is required for a variant
  sizeType      String // Size Type is required for a variant
  sizes         String? // For custom size input
  stockQuantity Int       @default(0) // Stock quantity for this specific variant
  skuSuffix     String? // Suffix to append to the main product SKU for this variant
  regularPrice  Float // Custom regular price for this variant
  salePrice     Float? // Custom sale price for this variant (optional)
  images        String[] @default([])
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Add a unique constraint to ensure no duplicate variants for the same product based on color and sizeType
  @@unique([productId, color, sizeType, sizes]) // Include customSize in unique constraint if it further defines uniqueness
  @@index([productId])
  @@index([skuSuffix]) // Index for faster lookup if you search by SKU suffix
}

model Order {
  id            String        @id @default(uuid())
  userId        String
  user          User          @relation("UserOrders", fields: [userId], references: [id]) // Unique relation name for User
  status        String // Pending, Completed, Cancelled, etc.
  totalAmount   Float // Total amount for the order
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  transactionId String?
  transaction   Transaction?  @relation("OrderTransaction") // Unique relation name for Transaction
  orderDetails  OrderDetail[] @relation("OrderOrderDetails") // Unique relation name for OrderDetails

  @@index([userId]) // Index on userId for faster filtering by user
  @@index([status]) // Index on status for faster filtering by order status
  @@index([createdAt]) // Index on createdAt for faster date-based queries
  @@index([transactionId]) // Index on transactionId for faster lookup
}

model OrderDetail {
  id           String   @id @default(uuid())
  sku          String
  orderId      String
  order        Order    @relation("OrderOrderDetails", fields: [orderId], references: [id]) // Unique relation name for Order
  productId    String
  product      Product  @relation("ProductOrderDetails", fields: [productId], references: [id]) // Unique relation name for Product
  quantity     Int
  price        Float // Price of the product per unit
  total        Float // Total price for the quantity
  productName  String // Denormalized product name (for avoiding join with Product table)
  categoryName String // Denormalized category name (for avoiding join with Category table)
  sizeName     String // Denormalized size name (for avoiding join with Size table)
  createdAt    DateTime @default(now())

  @@index([productId]) // Index on productId for fast lookup
  @@index([orderId]) // Index on orderId for better performance
}

model Transaction {
  id            String   @id @default(uuid())
  transactionId String
  orderId       String   @unique
  amount        Float // Amount for the transaction
  status        String // Transaction status: Pending, Successful, Failed
  createdAt     DateTime @default(now())
  order         Order    @relation("OrderTransaction", fields: [orderId], references: [id]) // Unique relation name for Order

  @@index([orderId]) // Index on orderId for faster lookup
  @@index([status]) // Index on status for faster filtering by transaction status
}

model WalmartOrder {
  id                String   @id @default(uuid())
  orderId           String   @unique
  orderCreationDate DateTime // Date when the order was created
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([orderId]) // Index on createdAt for faster date-based queries
}

model EbayOrder {
  id                String   @id @default(uuid())
  orderId           String   @unique
  status            String // Pending, Completed, Cancelled, etc.
  orderCreationDate DateTime // Date when the order was created
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([status]) // Index on status for faster filtering by order status
  @@index([createdAt]) // Index on createdAt for faster date-based queries
}

model SheinOrder {
  id                String   @id @default(uuid())
  orderId           String   @unique
  status            String // Pending, Completed, Cancelled, etc.
  orderCreationDate DateTime // Date when the order was created
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([status]) // Index on status for faster filtering by order status
  @@index([createdAt]) // Index on createdAt for faster date-based queries
}

model WooComOrder {
  id                String   @id @default(uuid())
  orderId           String   @unique
  status            String
  orderCreationDate DateTime
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([createdAt])
}

model ApiToken {
  id       String   @id @default(uuid()) // Unique Token ID
  platform Platform @unique // Enum (eBay, Walmart, Shein)

  accessToken  String // Short-lived access token
  refreshToken String // Long-lived refresh token
  expiresAt    DateTime // Access token expiry

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Notification {
  id        String   @id @default(uuid())
  title     String
  message   String
  location  String
  selledBy  SellBy
  isRead    Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum SellBy {
  EBAY1
  EBAY2
  EBAY3
  WEBSITE
  WALMART
  SHEIN
  WOOCOM
  PHYSICAL
}

enum Platform {
  EBAY
  EBAY2
  EBAY3
  WALMART
  SHEIN
}

enum Loyalty {
  Not_Eligible
  Eligible
  Loyal
}

enum UserRole {
  Admin
  OfficeEmpolyee
  WareHouse
  PlatformUser
  Cashier
  SuperAdmin
}
